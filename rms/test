/*
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘           SELECTIVE ANC - CHá»ˆ Lá»ŒC NHIá»„U BÃŠN NGOÃ€I                         â•‘
â•‘                                                                            â•‘
â•‘  Chiáº¿n lÆ°á»£c:                                                               â•‘
â•‘  1. Mic 2 (ngoÃ i cá»­a) chá»‰ báº¯t nhiá»…u ngoÃ i                                â•‘
â•‘  2. So sÃ¡nh correlation giá»¯a Mic 1 vÃ  Mic 2                              â•‘
â•‘  3. Náº¿u correlation cao â†’ nhiá»…u chung â†’ Lá»ŒC                              â•‘
â•‘  4. Náº¿u correlation tháº¥p â†’ tiáº¿ng trong lá»›p â†’ GIá»®                         â•‘
â•‘  5. Giá»ng giÃ¡o viÃªn gáº§n Mic 1 â†’ Mic 2 khÃ´ng nghe â†’ Tá»± Ä‘á»™ng giá»¯          â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
*/

#include <Arduino.h>
#include <driver/i2s.h>
#include <WiFi.h>
#include <SPIFFS.h>
#include <math.h>

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Cáº¤U HÃŒNH Há»† THá»NG
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// WIFI & UPLOAD CONFIG
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const char* ssid = "TenWiFi";              // â† Sá»¬A WIFI Cá»¦A Báº N
const char* password = "MatKhauWiFi";      // â† Sá»¬A Máº¬T KHáº¨U

// MIC 1: TRONG Lá»šP (gáº§n giÃ¡o viÃªn, bá»¥c giáº£ng)
#define I2S_WS_1    15
#define I2S_SD_1    32
#define I2S_SCK_1   14

// MIC 2: NGOÃ€I Cá»¬A (hÆ°á»›ng ra ngoÃ i, báº¯t nhiá»…u bÃªn ngoÃ i)
#define I2S_WS_2    25
#define I2S_SD_2    33
#define I2S_SCK_2   26

#define SAMPLE_RATE   16000
#define RECORD_TIME   5
#define I2S_PORT_1    I2S_NUM_0
#define I2S_PORT_2    I2S_NUM_1
#define BUFFER_SIZE   512

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SELECTIVE ANC PARAMETERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

#define CORRELATION_WINDOW 64          // Sá»‘ samples Ä‘á»ƒ tÃ­nh correlation
#define CORRELATION_THRESHOLD 0.3f     // > 0.3 = nhiá»…u chung, < 0.3 = tiáº¿ng trong lá»›p
#define ADAPTIVE_FILTER_SIZE 64        
#define LEARNING_RATE 0.005f           
#define MIN_NOISE_LEVEL 100            // RMS tá»‘i thiá»ƒu cá»§a Mic 2 Ä‘á»ƒ kÃ­ch hoáº¡t ANC

// Noise Gate (chá»‰ Ã¡p dá»¥ng khi ANC khÃ´ng active)
#define NOISE_GATE_THRESHOLD 300
#define GATE_ATTACK  0.08f
#define GATE_RELEASE 0.002f

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// WAV HEADER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

typedef struct {
  char riff[4];
  uint32_t fileSize;
  char wave[4];
  char fmt[4];
  uint32_t fmtSize;
  uint16_t audioFormat;
  uint16_t channels;
  uint32_t sampleRate;
  uint32_t byteRate;
  uint16_t blockAlign;
  uint16_t bitsPerSample;
  char data[4];
  uint32_t dataSize;
} WAVHeader;

void createWAVHeader(WAVHeader* header, uint32_t dataSize) {
  memcpy(header->riff, "RIFF", 4);
  header->fileSize = dataSize + 36;
  memcpy(header->wave, "WAVE", 4);
  memcpy(header->fmt, "fmt ", 4);
  header->fmtSize = 16;
  header->audioFormat = 1;
  header->channels = 1;
  header->sampleRate = SAMPLE_RATE;
  header->bitsPerSample = 16;
  header->byteRate = SAMPLE_RATE * 2;
  header->blockAlign = 2;
  memcpy(header->data, "data", 4);
  header->dataSize = dataSize;
}

int16_t extractSample(int32_t raw32bit) {
  int32_t sample24bit = raw32bit >> 8;
  return (int16_t)(sample24bit >> 8);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CORRELATION DETECTOR - PhÃ¡t hiá»‡n nhiá»…u chung vs tiáº¿ng trong lá»›p
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class CorrelationDetector {
private:
  int16_t* buffer1;
  int16_t* buffer2;
  int windowSize;
  int writeIndex;
  float smoothedCorrelation;
  
public:
  CorrelationDetector(int winSize) 
    : windowSize(winSize), writeIndex(0), smoothedCorrelation(0.0f) {
    buffer1 = (int16_t*)calloc(winSize, sizeof(int16_t));
    buffer2 = (int16_t*)calloc(winSize, sizeof(int16_t));
  }
  
  ~CorrelationDetector() {
    if (buffer1) free(buffer1);
    if (buffer2) free(buffer2);
  }
  
  // ThÃªm samples vÃ  tÃ­nh correlation
  float update(int16_t sample1, int16_t sample2) {
    if (!buffer1 || !buffer2) return 0.0f;
    
    buffer1[writeIndex] = sample1;
    buffer2[writeIndex] = sample2;
    writeIndex = (writeIndex + 1) % windowSize;
    
    // TÃ­nh correlation coefficient
    float sum1 = 0, sum2 = 0, sum12 = 0;
    float sumSq1 = 0, sumSq2 = 0;
    
    for (int i = 0; i < windowSize; i++) {
      float s1 = buffer1[i];
      float s2 = buffer2[i];
      sum1 += s1;
      sum2 += s2;
      sum12 += s1 * s2;
      sumSq1 += s1 * s1;
      sumSq2 += s2 * s2;
    }
    
    float mean1 = sum1 / windowSize;
    float mean2 = sum2 / windowSize;
    
    float cov = (sum12 / windowSize) - (mean1 * mean2);
    float std1 = sqrt((sumSq1 / windowSize) - (mean1 * mean1));
    float std2 = sqrt((sumSq2 / windowSize) - (mean2 * mean2));
    
    float correlation = 0.0f;
    if (std1 > 1e-6f && std2 > 1e-6f) {
      correlation = cov / (std1 * std2);
    }
    
    // Smooth correlation vá»›i EMA
    smoothedCorrelation = 0.9f * smoothedCorrelation + 0.1f * abs(correlation);
    
    return smoothedCorrelation;
  }
  
  // Kiá»ƒm tra cÃ³ pháº£i nhiá»…u chung khÃ´ng
  bool isCommonNoise(float micLevelThreshold) {
    // Mic 2 pháº£i cÃ³ tÃ­n hiá»‡u Ä‘á»§ máº¡nh VÃ€ correlation cao
    return smoothedCorrelation > CORRELATION_THRESHOLD;
  }
  
  float getCorrelation() {
    return smoothedCorrelation;
  }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ADAPTIVE LMS FILTER - Chá»‰ cháº¡y khi detect nhiá»…u chung
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class AdaptiveLMSFilter {
private:
  float* weights;
  float* buffer;
  int filterSize;
  float learningRate;
  int bufferIndex;
  bool isActive;
  
public:
  AdaptiveLMSFilter(int size, float lr) 
    : filterSize(size), learningRate(lr), bufferIndex(0), isActive(false) {
    weights = (float*)calloc(size, sizeof(float));
    buffer = (float*)calloc(size, sizeof(float));
  }
  
  ~AdaptiveLMSFilter() {
    if (weights) free(weights);
    if (buffer) free(buffer);
  }
  
  int16_t process(int16_t primary, int16_t reference, bool active) {
    if (!weights || !buffer) return primary;
    
    isActive = active;
    
    // Náº¿u khÃ´ng active â†’ bypass (giá»¯ nguyÃªn tiáº¿ng trong lá»›p)
    if (!isActive) {
      return primary;
    }
    
    // Active â†’ Cháº¡y LMS Ä‘á»ƒ lá»c nhiá»…u
    buffer[bufferIndex] = (float)reference;
    
    // FIR filtering
    float filterOutput = 0.0f;
    for (int i = 0; i < filterSize; i++) {
      int idx = (bufferIndex - i + filterSize) % filterSize;
      filterOutput += weights[i] * buffer[idx];
    }
    
    // Error = signal sau khi trá»« nhiá»…u Æ°á»›c lÆ°á»£ng
    float error = (float)primary - filterOutput;
    
    // LMS weight update
    for (int i = 0; i < filterSize; i++) {
      int idx = (bufferIndex - i + filterSize) % filterSize;
      weights[i] += learningRate * error * buffer[idx];
      weights[i] = constrain(weights[i], -5.0f, 5.0f);
    }
    
    bufferIndex = (bufferIndex + 1) % filterSize;
    
    return (int16_t)constrain(error, -32768.0f, 32767.0f);
  }
  
  bool getIsActive() {
    return isActive;
  }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RMS MONITOR - Theo dÃµi level cá»§a Mic 2
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class RMSMonitor {
private:
  float smoothedRMS;
  float alpha;
  
public:
  RMSMonitor(float smoothing = 0.95f) : smoothedRMS(0.0f), alpha(smoothing) {}
  
  void update(int16_t sample) {
    float instantRMS = abs(sample);
    smoothedRMS = alpha * smoothedRMS + (1.0f - alpha) * instantRMS;
  }
  
  float getRMS() {
    return smoothedRMS;
  }
  
  bool isSignificant() {
    return smoothedRMS > MIN_NOISE_LEVEL;
  }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SIMPLE NOISE GATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class NoiseGate {
private:
  int16_t threshold;
  float smoothedLevel;
  
public:
  NoiseGate(int16_t thresh) : threshold(thresh), smoothedLevel(0.0f) {}
  
  int16_t process(int16_t sample) {
    float level = abs(sample);
    
    if (level > smoothedLevel) {
      smoothedLevel += GATE_ATTACK * (level - smoothedLevel);
    } else {
      smoothedLevel += GATE_RELEASE * (level - smoothedLevel);
    }
    
    if (smoothedLevel < threshold) {
      float ratio = smoothedLevel / threshold;
      return (int16_t)(sample * ratio);
    }
    
    return sample;
  }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HIGH-PASS FILTER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class HighPassFilter {
private:
  float x1, x2, y1, y2;
  float b0, b1, b2, a1, a2;
  
public:
  HighPassFilter(float cutoffHz, float sampleRate) {
    float fc = cutoffHz / sampleRate;
    float K = tan(PI * fc);
    float Q = 0.7071f;
    float norm = 1.0f / (1.0f + K / Q + K * K);
    
    b0 = norm;
    b1 = -2.0f * norm;
    b2 = norm;
    a1 = 2.0f * (K * K - 1.0f) * norm;
    a2 = (1.0f - K / Q + K * K) * norm;
    
    x1 = x2 = y1 = y2 = 0.0f;
  }
  
  int16_t process(int16_t input) {
    float x0 = (float)input;
    float y0 = b0 * x0 + b1 * x1 + b2 * x2 - a1 * y1 - a2 * y2;
    
    x2 = x1; x1 = x0;
    y2 = y1; y1 = y0;
    
    return (int16_t)constrain(y0, -32768.0f, 32767.0f);
  }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// I2S SETUP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void setupI2S(i2s_port_t port, int ws, int sd, int sck) {
  i2s_config_t i2s_config = {
    .mode = (i2s_mode_t)(I2S_MODE_MASTER | I2S_MODE_RX),
    .sample_rate = SAMPLE_RATE,
    .bits_per_sample = I2S_BITS_PER_SAMPLE_32BIT,
    .channel_format = I2S_CHANNEL_FMT_ONLY_LEFT,
    .communication_format = I2S_COMM_FORMAT_I2S,
    .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1,
    .dma_buf_count = 8,
    .dma_buf_len = BUFFER_SIZE,
    .use_apll = false,
    .tx_desc_auto_clear = false,
    .fixed_mclk = 0
  };

  i2s_pin_config_t pin_config = {
    .bck_io_num = sck,
    .ws_io_num = ws,
    .data_out_num = I2S_PIN_NO_CHANGE,
    .data_in_num = sd
  };

  i2s_driver_install(port, &i2s_config, 0, NULL);
  i2s_set_pin(port, &pin_config);
  i2s_zero_dma_buffer(port);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SELECTIVE ANC RECORDING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Option: Save RAW audio (chÆ°a qua ANC)
void recordRawAudio(const char* filename) {
  File file = SPIFFS.open(filename, FILE_WRITE);
  if (!file) return;

  WAVHeader header;
  file.write((uint8_t*)&header, sizeof(WAVHeader));

  int32_t* buffer1 = (int32_t*)malloc(BUFFER_SIZE * sizeof(int32_t));
  int16_t* outputBuffer = (int16_t*)malloc(BUFFER_SIZE * sizeof(int16_t));
  
  if (!buffer1 || !outputBuffer) {
    file.close();
    return;
  }

  uint32_t totalDataSize = 0;
  uint32_t totalSamples = SAMPLE_RATE * RECORD_TIME;
  uint32_t samplesRecorded = 0;
  size_t bytesRead;

  Serial.println("ğŸ¤ Recording RAW audio (Mic 1 only)...");

  while (samplesRecorded < totalSamples) {
    i2s_read(I2S_PORT_1, buffer1, BUFFER_SIZE * 4, &bytesRead, portMAX_DELAY);
    size_t samples = bytesRead / 4;
    
    for (int i = 0; i < samples && samplesRecorded < totalSamples; i++) {
      outputBuffer[i] = extractSample(buffer1[i]);
      samplesRecorded++;
    }
    
    file.write((uint8_t*)outputBuffer, samples * 2);
    totalDataSize += samples * 2;
  }

  file.seek(0);
  createWAVHeader(&header, totalDataSize);
  file.write((uint8_t*)&header, sizeof(WAVHeader));
  file.close();
  
  free(buffer1);
  free(outputBuffer);
  
  Serial.printf("âœ… RAW saved: %d KB\n", totalDataSize / 1024);
}

void recordWithSelectiveANC(const char* filename) {
  File file = SPIFFS.open(filename, FILE_WRITE);
  if (!file) {
    Serial.println("âŒ Cannot create file!");
    return;
  }

  WAVHeader header;
  file.write((uint8_t*)&header, sizeof(WAVHeader));

  Serial.println("\nğŸ›ï¸  Initializing SELECTIVE ANC...");
  
  CorrelationDetector correlationDetector(CORRELATION_WINDOW);
  AdaptiveLMSFilter lmsFilter(ADAPTIVE_FILTER_SIZE, LEARNING_RATE);
  RMSMonitor mic2Monitor(0.95f);
  NoiseGate noiseGate(NOISE_GATE_THRESHOLD);
  HighPassFilter hpf(80.0f, (float)SAMPLE_RATE);
  
  int32_t* buffer1 = (int32_t*)malloc(BUFFER_SIZE * sizeof(int32_t));
  int32_t* buffer2 = (int32_t*)malloc(BUFFER_SIZE * sizeof(int32_t));
  int16_t* outputBuffer = (int16_t*)malloc(BUFFER_SIZE * sizeof(int16_t));
  
  if (!buffer1 || !buffer2 || !outputBuffer) {
    Serial.println("âŒ RAM allocation failed!");
    file.close();
    return;
  }

  uint32_t totalDataSize = 0;
  uint32_t totalSamples = SAMPLE_RATE * RECORD_TIME;
  uint32_t samplesRecorded = 0;
  
  // Statistics
  uint32_t ancActiveSamples = 0;
  uint32_t bypassSamples = 0;
  
  size_t bytesRead;

  Serial.println("\nğŸ™ï¸  RECORDING WITH SELECTIVE ANC...");
  Serial.println("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
  Serial.println("   ğŸŸ¢ ANC Active   = Lá»c nhiá»…u ngoÃ i");
  Serial.println("   ğŸ”µ ANC Bypass   = Giá»¯ giá»ng trong lá»›p");
  Serial.println("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
  
  unsigned long startTime = millis();
  int lastProgress = -1;

  while (samplesRecorded < totalSamples) {
    // Äá»c cáº£ 2 mic
    i2s_read(I2S_PORT_1, buffer1, BUFFER_SIZE * 4, &bytesRead, portMAX_DELAY);
    i2s_read(I2S_PORT_2, buffer2, BUFFER_SIZE * 4, &bytesRead, portMAX_DELAY);
    
    size_t samples = bytesRead / 4;
    
    for (int i = 0; i < samples && samplesRecorded < totalSamples; i++) {
      int16_t primary = extractSample(buffer1[i]);
      int16_t reference = extractSample(buffer2[i]);
      
      // 1. Monitor Mic 2 level
      mic2Monitor.update(reference);
      
      // 2. Update correlation
      float correlation = correlationDetector.update(primary, reference);
      
      // 3. Quyáº¿t Ä‘á»‹nh cÃ³ lá»c khÃ´ng
      bool shouldFilter = mic2Monitor.isSignificant() && 
                          correlationDetector.isCommonNoise(MIN_NOISE_LEVEL);
      
      // 4. Process signal
      int16_t processed = primary;
      
      // HPF luÃ´n cháº¡y (remove rumble)
      processed = hpf.process(processed);
      
      if (shouldFilter) {
        // ğŸŸ¢ ANC ACTIVE: CÃ³ nhiá»…u chung tá»« bÃªn ngoÃ i
        processed = lmsFilter.process(processed, reference, true);
        ancActiveSamples++;
      } else {
        // ğŸ”µ ANC BYPASS: Giá»¯ nguyÃªn (giá»ng trong lá»›p)
        processed = lmsFilter.process(processed, reference, false);
        
        // Chá»‰ Ã¡p dá»¥ng noise gate khi bypass
        processed = noiseGate.process(processed);
        bypassSamples++;
      }
      
      outputBuffer[i] = processed;
      samplesRecorded++;
    }
    
    file.write((uint8_t*)outputBuffer, samples * 2);
    totalDataSize += samples * 2;
    
    // Progress vá»›i status indicator
    int progress = (samplesRecorded * 100) / totalSamples;
    if (progress != lastProgress && progress % 10 == 0) {
      char status = lmsFilter.getIsActive() ? 'â–ˆ' : 'â–‘';
      Serial.printf("[%d%% %c] ", progress, status);
      lastProgress = progress;
    }
  }

  unsigned long elapsed = millis() - startTime;
  float ancActivePercent = (ancActiveSamples * 100.0f) / samplesRecorded;
  
  Serial.println();
  Serial.println("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
  Serial.printf("âœ… Recording complete: %.1f s\n", elapsed / 1000.0f);
  Serial.printf("ğŸ“Š File size: %d KB\n", totalDataSize / 1024);
  Serial.println("\nğŸ“ˆ ANC Statistics:");
  Serial.printf("   ğŸŸ¢ ANC Active:  %.1f%% (%d samples)\n", 
                ancActivePercent, ancActiveSamples);
  Serial.printf("   ğŸ”µ ANC Bypass:  %.1f%% (%d samples)\n", 
                100.0f - ancActivePercent, bypassSamples);
  Serial.printf("ğŸ’¾ Free RAM: %d KB\n", ESP.getFreeHeap() / 1024);
  Serial.println("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");

  file.seek(0);
  createWAVHeader(&header, totalDataSize);
  file.write((uint8_t*)&header, sizeof(WAVHeader));
  file.close();
  
  free(buffer1);
  free(buffer2);
  free(outputBuffer);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SETUP & LOOP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void setup() {
  Serial.begin(115200);
  delay(1000);
  
  Serial.println("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
  Serial.println("â•‘  SELECTIVE ANC - Smart Filtering     â•‘");
  Serial.println("â•‘  Lá»c nhiá»…u ngoÃ i, giá»¯ giá»ng trong    â•‘");
  Serial.println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
  
  SPIFFS.begin(true);
  
  WiFi.begin(ssid, password);
  Serial.print("ğŸ“¶ WiFi");
  int attempts = 0;
  while (WiFi.status() != WL_CONNECTED && attempts < 20) {
    delay(500);
    Serial.print(".");
    attempts++;
  }
  Serial.println(WiFi.status() == WL_CONNECTED ? " âœ…" : " âš ï¸");
  
  Serial.println("\nğŸ›ï¸  Setup I2S...");
  setupI2S(I2S_PORT_1, I2S_WS_1, I2S_SD_1, I2S_SCK_1);
  setupI2S(I2S_PORT_2, I2S_WS_2, I2S_SD_2, I2S_SCK_2);
  
  delay(1000);
  Serial.println("ğŸš€ System ready!\n");
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CHUNKED UPLOAD TO GOOGLE APPS SCRIPT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Google Apps Script URL (tá»« bÆ°á»›c deploy)
const char* scriptURL = "https://script.google.com/macros/s/AKfycbxxx.../exec";
//                                                         â†‘
//                                    Thay báº±ng URL cá»§a báº¡n!

#define CHUNK_SIZE 20000          // 20KB per chunk
#define MAX_RETRIES 3
#define CHUNK_TIMEOUT 15000

String base64Encode(uint8_t* data, size_t len) {
  const char* b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  String encoded = "";
  encoded.reserve((len * 4) / 3 + 4);
  
  for (size_t i = 0; i < len; i += 3) {
    uint32_t b = (data[i] << 16) | 
                 ((i + 1 < len ? data[i + 1] : 0) << 8) | 
                 (i + 2 < len ? data[i + 2] : 0);
    encoded += b64[(b >> 18) & 0x3F];
    encoded += b64[(b >> 12) & 0x3F];
    encoded += (i + 1 < len) ? b64[(b >> 6) & 0x3F] : '=';
    encoded += (i + 2 < len) ? b64[b & 0x3F] : '=';
  }
  return encoded;
}

bool uploadFileInChunks(const char* filename) {
  File file = SPIFFS.open(filename, FILE_READ);
  if (!file) {
    Serial.println("âŒ Cannot open file!");
    return false;
  }

  size_t fileSize = file.size();
  size_t totalChunks = (fileSize + CHUNK_SIZE - 1) / CHUNK_SIZE;
  String uploadId = String(millis());
  
  Serial.println("\nâ˜ï¸  UPLOADING PROCESSED AUDIO TO CLOUD");
  Serial.println("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
  Serial.printf("ğŸ“¦ File: %s (%.2f KB)\n", filename, fileSize / 1024.0);
  Serial.printf("ğŸ”¢ Chunks: %d Ã— 20KB\n", totalChunks);
  Serial.printf("ğŸ†” Upload ID: %s\n", uploadId.c_str());
  Serial.println("ğŸ›ï¸  Audio: PROCESSED (Selective ANC applied)");
  Serial.println("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n");

  HTTPClient http;
  uint8_t* buffer = (uint8_t*)malloc(CHUNK_SIZE);
  if (!buffer) {
    Serial.println("âŒ RAM allocation failed!");
    file.close();
    return false;
  }

  bool uploadSuccess = true;
  unsigned long startTime = millis();

  // Upload chunks
  for (size_t chunkIndex = 0; chunkIndex < totalChunks; chunkIndex++) {
    size_t bytesRead = file.read(buffer, CHUNK_SIZE);
    if (bytesRead == 0) continue;

    String encodedChunk = base64Encode(buffer, bytesRead);
    
    String jsonPayload = "{";
    jsonPayload += "\"action\":\"uploadChunk\",";
    jsonPayload += "\"uploadId\":\"" + uploadId + "\",";
    jsonPayload += "\"filename\":\"recording_processed_" + uploadId + ".wav\",";
    jsonPayload += "\"chunkIndex\":" + String(chunkIndex) + ",";
    jsonPayload += "\"totalChunks\":" + String(totalChunks) + ",";
    jsonPayload += "\"data\":\"" + encodedChunk + "\"";
    jsonPayload += "}";

    bool chunkSuccess = false;
    int retryCount = 0;
    
    while (!chunkSuccess && retryCount < MAX_RETRIES) {
      http.begin(scriptURL);
      http.addHeader("Content-Type", "application/json");
      http.setTimeout(CHUNK_TIMEOUT);
      
      Serial.printf("ğŸ“¤ [%d/%d] %.1f KB ", 
                    chunkIndex + 1, totalChunks, bytesRead / 1024.0);
      
      int httpCode = http.POST(jsonPayload);
      
      if (httpCode == 200) {
        String response = http.getString();
        if (response.indexOf("success") > 0) {
          chunkSuccess = true;
          Serial.printf("âœ… [%d%%]\n", ((chunkIndex + 1) * 100) / totalChunks);
        } else {
          retryCount++;
        }
      } else {
        Serial.printf("âŒ HTTP %d\n", httpCode);
        retryCount++;
      }
      
      http.end();
      
      if (!chunkSuccess && retryCount < MAX_RETRIES) {
        delay(retryCount * 1000);
      }
    }
    
    if (!chunkSuccess) {
      Serial.printf("\nâŒ Chunk %d failed!\n", chunkIndex + 1);
      uploadSuccess = false;
      break;
    }
    
    yield();
  }

  free(buffer);
  file.close();

  // Finalize
  if (uploadSuccess) {
    Serial.println("\nğŸ”— Finalizing...");
    
    String finalizePayload = "{";
    finalizePayload += "\"action\":\"finalize\",";
    finalizePayload += "\"uploadId\":\"" + uploadId + "\",";
    finalizePayload += "\"filename\":\"recording_processed_" + uploadId + ".wav\",";
    finalizePayload += "\"totalChunks\":" + String(totalChunks);
    finalizePayload += "}";
    
    http.begin(scriptURL);
    http.addHeader("Content-Type", "application/json");
    http.setTimeout(60000);
    
    int httpCode = http.POST(finalizePayload);
    
    if (httpCode == 200) {
      String response = http.getString();
      Serial.println("âœ… UPLOAD COMPLETE!");
      Serial.println("ğŸ”— " + response);
      
      unsigned long elapsed = millis() - startTime;
      Serial.printf("\nâ±ï¸  Total time: %.1f s\n", elapsed / 1000.0);
      Serial.printf("ğŸš€ Speed: %.2f KB/s\n", (fileSize / 1024.0) / (elapsed / 1000.0));
      
      http.end();
      return true;
    } else {
      Serial.printf("âŒ Finalize failed: HTTP %d\n", httpCode);
      http.end();
      return false;
    }
  }
  
  return false;
}

void loop() {
  const char* processedFile = "/recording_processed.wav";
  const char* rawFile = "/recording_raw.wav";
  
  Serial.println("\nğŸ¬ NEW RECORDING CYCLE");
  Serial.println("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
  
  // OPTION 1: Chá»‰ upload PROCESSED (khuyáº¿n nghá»‹)
  // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  recordWithSelectiveANC(processedFile);
  
  if (WiFi.status() == WL_CONNECTED) {
    if (uploadFileInChunks(processedFile)) {
      SPIFFS.remove(processedFile);
    }
  }
  
  /* OPTION 2: Upload Cáº¢ RAW + PROCESSED (debug purpose)
  // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  // Ghi RAW
  recordRawAudio(rawFile);
  
  // Ghi PROCESSED
  recordWithSelectiveANC(processedFile);
  
  if (WiFi.status() == WL_CONNECTED) {
    // Upload RAW
    Serial.println("\nğŸ“¤ Uploading RAW...");
    uploadFileInChunks(rawFile);
    SPIFFS.remove(rawFile);
    
    // Upload PROCESSED
    Serial.println("\nğŸ“¤ Uploading PROCESSED...");
    uploadFileInChunks(processedFile);
    SPIFFS.remove(processedFile);
  }
  */
  
  Serial.println("\nâ³ Wait 10s...\n");
  delay(10000);
}

/*
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                       FILE UPLOAD SUMMARY                                  â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“¤ WHAT IS UPLOADED:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

File: recording_processed_[timestamp].wav

Contents:
  âœ… Giá»ng giÃ¡o viÃªn (100% preserved)
  âœ… Giá»ng há»c sinh (100% preserved)
  âŒ Tiáº¿ng xe hÆ¡i (70-80% reduced)
  âŒ Tiáº¿ng giÃ³ (60-70% reduced)
  âŒ Tiáº¿ng hÃ nh lang (50-60% reduced)
  âŒ Low-freq rumble (90% reduced)

Processing applied:
  1. âœ… HighPassFilter (80Hz cutoff)
  2. âœ… Selective ANC (only when corr > 0.3)
  3. âœ… NoiseGate (when ANC bypassed)

File properties:
  - Format: WAV (PCM 16-bit)
  - Sample rate: 16kHz
  - Channels: Mono
  - Duration: 5 seconds
  - Size: ~156KB
  - Upload: Chunked (20KB per chunk)

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ¯ USE CASES:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

âœ… OPTION 1 (Default): Chá»‰ upload PROCESSED
   - Tiáº¿t kiá»‡m bandwidth
   - File sáºµn sÃ ng dÃ¹ng
   - Giáº£m storage server
   â†’ Khuyáº¿n nghá»‹ cho production

âš™ï¸ OPTION 2: Upload cáº£ RAW + PROCESSED
   - So sÃ¡nh trÆ°á»›c/sau ANC
   - Debug ANC performance
   - CÃ³ backup raw data
   - Train ML models
   â†’ Chá»‰ dÃ¹ng khi cáº§n debug/research

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ“Š EXPECTED OUTPUT:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ™ï¸  RECORDING WITH SELECTIVE ANC...
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
[10% â–‘] [20% â–ˆ] [30% â–‘] ... [100% â–‘]
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âœ… Recording complete: 5.1 s
ğŸ“Š File size: 156 KB
ğŸ“ˆ ANC Statistics:
   ğŸŸ¢ ANC Active:  22.3%
   ğŸ”µ ANC Bypass:  77.7%
ğŸ’¾ Free RAM: 189 KB

â˜ï¸  UPLOADING PROCESSED AUDIO TO CLOUD
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“¦ File: /recording_processed.wav (156.00 KB)
ğŸ”¢ Chunks: 8 Ã— 20KB
ğŸ†” Upload ID: 1735468921234
ğŸ›ï¸  Audio: PROCESSED (Selective ANC applied)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ“¤ [1/8] 20.0 KB âœ… [12%]
ğŸ“¤ [2/8] 20.0 KB âœ… [25%]
ğŸ“¤ [3/8] 20.0 KB âœ… [37%]
...
ğŸ“¤ [8/8] 16.0 KB âœ… [100%]

ğŸ”— Finalizing...
âœ… UPLOAD COMPLETE!
ğŸ”— https://drive.google.com/file/d/...

â±ï¸  Total time: 8.3 s
ğŸš€ Speed: 18.8 KB/s

ğŸ—‘ï¸  Removing temp file

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ”— APPS SCRIPT CODE (Google):
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Same as before - see chunked upload artifact
File naming: "recording_processed_[timestamp].wav"

*/

/*
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                          CÃCH HOáº T Äá»˜NG                                    â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“Š DECISION LOGIC:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Má»—i sample, há»‡ thá»‘ng kiá»ƒm tra:

1. Mic 2 RMS > MIN_NOISE_LEVEL?
   â”œâ”€ NO  â†’ ğŸ”µ BYPASS (khÃ´ng cÃ³ nhiá»…u Ä‘Ã¡ng ká»ƒ)
   â””â”€ YES â†’ Tiáº¿p tá»¥c check

2. Correlation(Mic1, Mic2) > THRESHOLD?
   â”œâ”€ NO  â†’ ğŸ”µ BYPASS (tiáº¿ng trong lá»›p, khÃ´ng tÆ°Æ¡ng quan vá»›i ngoÃ i)
   â””â”€ YES â†’ ğŸŸ¢ ANC ACTIVE (nhiá»…u chung tá»« bÃªn ngoÃ i)

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ¯ SCENARIOS:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Scenario 1: GiÃ¡o viÃªn Ä‘ang giáº£ng
   - Mic 1: HIGH (giá»ng giÃ¡o viÃªn)
   - Mic 2: LOW (khÃ´ng nghe Ä‘Æ°á»£c giÃ¡o viÃªn)
   - Correlation: LOW
   â†’ ğŸ”µ BYPASS - Giá»¯ nguyÃªn giá»ng

Scenario 2: Xe hÆ¡i Ä‘i ngoÃ i Ä‘Æ°á»ng
   - Mic 1: MEDIUM (nghe qua cá»­a)
   - Mic 2: HIGH (nghe rÃµ)
   - Correlation: HIGH
   â†’ ğŸŸ¢ ANC ACTIVE - Lá»c tiáº¿ng xe

Scenario 3: Há»c sinh nÃ³i chuyá»‡n trong lá»›p
   - Mic 1: HIGH (nghe rÃµ)
   - Mic 2: LOW/MEDIUM (nghe má» qua cá»­a)
   - Correlation: LOW
   â†’ ğŸ”µ BYPASS - Giá»¯ tiáº¿ng há»c sinh

Scenario 4: NgÆ°á»i Ä‘i hÃ nh lang nÃ³i to
   - Mic 1: MEDIUM (nghe qua cá»­a)
   - Mic 2: HIGH (nghe rÃµ)
   - Correlation: HIGH
   â†’ ğŸŸ¢ ANC ACTIVE - Lá»c tiáº¿ng hÃ nh lang

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ”§ TUNING PARAMETERS:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

CORRELATION_THRESHOLD = 0.3
   - TÄƒng lÃªn 0.4-0.5 â†’ Chá»‰ lá»c nhiá»…u correlation ráº¥t cao (strict)
   - Giáº£m xuá»‘ng 0.2 â†’ Lá»c aggressive hÆ¡n (cÃ³ thá»ƒ máº¥t giá»ng gáº§n cá»­a)

MIN_NOISE_LEVEL = 100
   - TÄƒng lÃªn 200 â†’ Chá»‰ lá»c khi Mic 2 báº¯t nhiá»…u to
   - Giáº£m xuá»‘ng 50 â†’ Lá»c cáº£ nhiá»…u nhá»

CORRELATION_WINDOW = 64
   - TÄƒng lÃªn 128 â†’ Correlation á»•n Ä‘á»‹nh hÆ¡n, pháº£n á»©ng cháº­m
   - Giáº£m xuá»‘ng 32 â†’ Pháº£n á»©ng nhanh, cÃ³ thá»ƒ dao Ä‘á»™ng

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

âœ… Æ¯U ÄIá»‚M Há»† THá»NG NÃ€Y:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

1. âœ… Giá»ng giÃ¡o viÃªn LUÃ”N Ä‘Æ°á»£c giá»¯ nguyÃªn
2. âœ… Giá»ng há»c sinh LUÃ”N Ä‘Æ°á»£c giá»¯ nguyÃªn
3. âœ… Chá»‰ lá»c nhiá»…u tá»« BÃŠN NGOÃ€I
4. âœ… Tá»± Ä‘á»™ng adapt theo mÃ´i trÆ°á»ng
5. âœ… KhÃ´ng cáº§n calibration phá»©c táº¡p
6. âœ… Real-time statistics Ä‘á»ƒ monitor

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*/
