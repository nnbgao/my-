/*
  === ESP32-S Master + TinyML Audio Classifier (4 Slaves) ===
  ğŸ“¡ Nháº­n dá»¯ liá»‡u tá»« 4 ESP32-C3 slaves qua ESP-NOW
  ğŸ¤– PhÃ¢n loáº¡i Ã¢m thanh báº±ng Edge Impulse TinyML:
     - Giá»ng giÃ¡o viÃªn (Teacher)
     - Giá»ng há»c sinh tÃ­ch cá»±c (Student Positive)
     - Giá»ng há»c sinh tiÃªu cá»±c (Student Negative)
     - Silence (im láº·ng)
  
  ğŸ¤ Theo dÃµi tá»«ng mic riÃªng biá»‡t + tá»•ng há»£p
*/

#include <Arduino.h>
#include <esp_now.h>
#include <WiFi.h>

// âš ï¸ UNCOMMENT sau khi cÃ³ model tá»« Edge Impulse
// #include <your_project_name_inferencing.h>

// ==== Cáº¥u trÃºc nháº­n dá»¯ liá»‡u tá»« Slave ====
typedef struct {
  float dB;
  float bassLevel;
  float midLevel;
  float trebleLevel;
  float dominantFreq;
  uint8_t micID;
} SoundData;

// ==== LÆ°u trá»¯ dá»¯ liá»‡u tá»«ng mic ====
struct MicData {
  SoundData lastData;
  unsigned long lastUpdate;
  bool isActive;
  
  // Buffer features cho ML
  float featureBuffer[6][50]; // 6 features x 50 samples
  int bufferIndex;
  
  // Thá»‘ng kÃª riÃªng tá»«ng mic
  int teacherCount;
  int studentPositiveCount;
  int studentNegativeCount;
  int silenceCount;
  
  MicData() : lastUpdate(0), isActive(false), bufferIndex(0),
              teacherCount(0), studentPositiveCount(0), 
              studentNegativeCount(0), silenceCount(0) {
    memset(&lastData, 0, sizeof(lastData));
  }
};

MicData mics[5]; // Index 0 khÃ´ng dÃ¹ng, mic 1-4

// ==== Thá»‘ng kÃª tá»•ng há»£p ====
struct GlobalStats {
  int totalTeacher;
  int totalStudentPositive;
  int totalStudentNegative;
  int totalSilence;
  unsigned long lastPrintTime;
  
  GlobalStats() : totalTeacher(0), totalStudentPositive(0),
                  totalStudentNegative(0), totalSilence(0),
                  lastPrintTime(0) {}
} globalStats;

// ==== NgÆ°á»¡ng ====
#define CONFIDENCE_THRESHOLD 0.70
#define SILENCE_DB_THRESHOLD 50.0
#define LOUD_DB_THRESHOLD 75.0
#define MIC_TIMEOUT 5000  // 5 giÃ¢y khÃ´ng nháº­n = offline

// ==== Callback nháº­n dá»¯ liá»‡u ESP-NOW (ESP-IDF v5.5+) ====
void OnDataRecv(const esp_now_recv_info *recv_info, const uint8_t *data, int len) {
  SoundData receivedData;
  memcpy(&receivedData, data, sizeof(receivedData));

  uint8_t micID = receivedData.micID;
  
  // Kiá»ƒm tra micID há»£p lá»‡
  if (micID < 1 || micID > 4) {
    Serial.printf("âŒ Mic ID khÃ´ng há»£p lá»‡: %d\n", micID);
    return;
  }

  // Cáº­p nháº­t dá»¯ liá»‡u cho mic tÆ°Æ¡ng á»©ng
  mics[micID].lastData = receivedData;
  mics[micID].lastUpdate = millis();
  mics[micID].isActive = true;

  // In dá»¯ liá»‡u nháº­n Ä‘Æ°á»£c
  Serial.println("\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
  Serial.printf("ğŸ“¥ MIC #%d | %.1f dB | %s\n", 
                micID, receivedData.dB, getMicStatus(micID).c_str());
  Serial.printf("   ğŸ¸ Bass:   %.1f dB\n", receivedData.bassLevel);
  Serial.printf("   ğŸ¤ Mid:    %.1f dB\n", receivedData.midLevel);
  Serial.printf("   ğŸº Treble: %.1f dB\n", receivedData.trebleLevel);
  Serial.printf("   ğŸµ Freq:   %.0f Hz\n", receivedData.dominantFreq);

  // Thu tháº­p features cho ML
  collectFeatures(micID, receivedData);

  // Khi Ä‘á»§ dá»¯ liá»‡u, phÃ¢n loáº¡i
  if (mics[micID].bufferIndex >= 50) {
    classifyMicAudio(micID);
    mics[micID].bufferIndex = 0;
  }
}

// ==== Láº¥y tráº¡ng thÃ¡i mic ====
String getMicStatus(uint8_t micID) {
  if (mics[micID].lastData.dB < SILENCE_DB_THRESHOLD) {
    return "ğŸ”‡ YÃªn láº·ng";
  } else if (mics[micID].lastData.dB > LOUD_DB_THRESHOLD) {
    return "ğŸ”Š á»’N!";
  } else {
    return "ğŸ”‰ BÃ¬nh thÆ°á»ng";
  }
}

// ==== Thu tháº­p features ====
void collectFeatures(uint8_t micID, SoundData &data) {
  int idx = mics[micID].bufferIndex;
  if (idx >= 50) return;

  mics[micID].featureBuffer[0][idx] = data.dB;
  mics[micID].featureBuffer[1][idx] = data.bassLevel;
  mics[micID].featureBuffer[2][idx] = data.midLevel;
  mics[micID].featureBuffer[3][idx] = data.trebleLevel;
  mics[micID].featureBuffer[4][idx] = data.dominantFreq;
  
  // Spectral variance
  float variance = abs(data.bassLevel - data.midLevel) + 
                   abs(data.midLevel - data.trebleLevel);
  mics[micID].featureBuffer[5][idx] = variance;

  mics[micID].bufferIndex++;
}

// ==== PhÃ¢n loáº¡i Ã¢m thanh tá»« 1 mic ====
void classifyMicAudio(uint8_t micID) {
  Serial.printf("\nğŸ¤– PhÃ¢n loáº¡i Mic #%d...\n", micID);

  // ===== Sá»¬ Dá»¤NG MODEL Tá»ª EDGE IMPULSE =====
  // Uncomment khi cÃ³ model
  /*
  signal_t signal;
  signal.total_length = 50 * 6;
  signal.get_data = [micID](size_t offset, size_t length, float *out_ptr) {
    return get_feature_data(micID, offset, length, out_ptr);
  };
  
  ei_impulse_result_t result;
  EI_IMPULSE_ERROR res = run_classifier(&signal, &result, false);
  
  if (res != EI_IMPULSE_OK) {
    Serial.printf("ERR: Failed (%d)\n", res);
    return;
  }
  
  float maxConfidence = 0;
  int maxIndex = -1;
  
  for (size_t i = 0; i < EI_CLASSIFIER_LABEL_COUNT; i++) {
    if (result.classification[i].value > maxConfidence) {
      maxConfidence = result.classification[i].value;
      maxIndex = i;
    }
  }
  
  if (maxConfidence < CONFIDENCE_THRESHOLD) {
    Serial.println("âš ï¸ Confidence tháº¥p");
    return;
  }
  
  String label = result.classification[maxIndex].label;
  updateMicStats(micID, label);
  */

  // ===== DEMO: Rule-based ====
  String classification = classifyByRules(micID);
  Serial.printf("   âœ… Káº¿t quáº£: %s\n", classification.c_str());
  updateMicStats(micID, classification);
}

// ==== PhÃ¢n loáº¡i báº±ng rules (thay tháº¿ báº±ng ML) ====
String classifyByRules(uint8_t micID) {
  float avgDB = 0, avgBass = 0, avgMid = 0, avgTreble = 0, avgFreq = 0;
  
  for (int i = 0; i < 50; i++) {
    avgDB += mics[micID].featureBuffer[0][i];
    avgBass += mics[micID].featureBuffer[1][i];
    avgMid += mics[micID].featureBuffer[2][i];
    avgTreble += mics[micID].featureBuffer[3][i];
    avgFreq += mics[micID].featureBuffer[4][i];
  }
  
  avgDB /= 50;
  avgBass /= 50;
  avgMid /= 50;
  avgTreble /= 50;
  avgFreq /= 50;

  // Silence
  if (avgDB < SILENCE_DB_THRESHOLD) {
    return "Silence";
  }
  
  // Teacher: giá»ng á»•n Ä‘á»‹nh, mid dominant, freq 150-600Hz
  if (avgFreq > 150 && avgFreq < 600 && avgMid > avgBass && avgDB < 70) {
    return "Teacher";
  }
  
  // Student Negative: á»“n lá»›n hoáº·c bass/treble cao báº¥t thÆ°á»ng
  if (avgDB > LOUD_DB_THRESHOLD || (avgBass > avgMid && avgTreble > avgMid)) {
    return "Student_Negative";
  }
  
  // Student Positive: giá»ng nÃ³i bÃ¬nh thÆ°á»ng
  if (avgFreq > 100 && avgFreq < 800 && avgDB > 55 && avgDB < 75) {
    return "Student_Positive";
  }

  return "Unknown";
}

// ==== Cáº­p nháº­t thá»‘ng kÃª tá»«ng mic ====
void updateMicStats(uint8_t micID, String classification) {
  if (classification == "Teacher") {
    mics[micID].teacherCount++;
    globalStats.totalTeacher++;
  } else if (classification == "Student_Positive") {
    mics[micID].studentPositiveCount++;
    globalStats.totalStudentPositive++;
  } else if (classification == "Student_Negative") {
    mics[micID].studentNegativeCount++;
    globalStats.totalStudentNegative++;
  } else if (classification == "Silence") {
    mics[micID].silenceCount++;
    globalStats.totalSilence++;
  }
}

// ==== Kiá»ƒm tra mic nÃ o offline ====
void checkMicStatus() {
  unsigned long now = millis();
  for (int i = 1; i <= 4; i++) {
    if (mics[i].isActive && (now - mics[i].lastUpdate > MIC_TIMEOUT)) {
      mics[i].isActive = false;
      Serial.printf("âš ï¸ Mic #%d OFFLINE\n", i);
    }
  }
}

// ==== In dashboard tá»•ng há»£p ====
void printDashboard() {
  unsigned long now = millis();
  if (now - globalStats.lastPrintTime < 10000) return; // Má»—i 10s
  
  globalStats.lastPrintTime = now;
  
  Serial.println("\n");
  Serial.println("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
  Serial.println("â•‘        ğŸ“Š DASHBOARD - Tá»”NG Há»¢P 4 MIC          â•‘");
  Serial.println("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
  
  // Tráº¡ng thÃ¡i tá»«ng mic
  for (int i = 1; i <= 4; i++) {
    Serial.printf("â•‘ Mic #%d: ", i);
    if (mics[i].isActive) {
      Serial.printf("âœ… %.1f dB | %s", 
                    mics[i].lastData.dB, 
                    getMicStatus(i).c_str());
      // Padding
      int spaces = 28 - String(mics[i].lastData.dB, 1).length() - getMicStatus(i).length();
      for (int j = 0; j < spaces; j++) Serial.print(" ");
      Serial.println("â•‘");
    } else {
      Serial.println("âŒ OFFLINE                        â•‘");
    }
  }
  
  Serial.println("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
  
  // Thá»‘ng kÃª tá»•ng há»£p
  int total = globalStats.totalTeacher + globalStats.totalStudentPositive + 
              globalStats.totalStudentNegative + globalStats.totalSilence;
  
  if (total > 0) {
    Serial.printf("â•‘ ğŸ‘¨â€ğŸ« GiÃ¡o viÃªn:      %3d (%2.0f%%)                â•‘\n", 
                  globalStats.totalTeacher, 
                  (globalStats.totalTeacher * 100.0) / total);
    Serial.printf("â•‘ ğŸ‘ HS TÃ­ch cá»±c:     %3d (%2.0f%%)                â•‘\n", 
                  globalStats.totalStudentPositive, 
                  (globalStats.totalStudentPositive * 100.0) / total);
    Serial.printf("â•‘ ğŸ‘ HS TiÃªu cá»±c:     %3d (%2.0f%%)                â•‘\n", 
                  globalStats.totalStudentNegative, 
                  (globalStats.totalStudentNegative * 100.0) / total);
    Serial.printf("â•‘ ğŸ”‡ Im láº·ng:         %3d (%2.0f%%)                â•‘\n", 
                  globalStats.totalSilence, 
                  (globalStats.totalSilence * 100.0) / total);
    
    // Cáº£nh bÃ¡o
    float negativePercent = (globalStats.totalStudentNegative * 100.0) / total;
    if (negativePercent > 30) {
      Serial.println("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
      Serial.println("â•‘ âš ï¸  Cáº¢NH BÃO: Má»©c Ä‘á»™ tiÃªu cá»±c cao!            â•‘");
    }
  }
  
  Serial.println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
}

// ==== Äá»‹nh vá»‹ nguá»“n á»“n ====
void locateNoiseSource() {
  float maxDB = 0;
  int noisyMic = 0;
  
  for (int i = 1; i <= 4; i++) {
    if (mics[i].isActive && mics[i].lastData.dB > maxDB) {
      maxDB = mics[i].lastData.dB;
      noisyMic = i;
    }
  }
  
  if (maxDB > LOUD_DB_THRESHOLD) {
    String position = "";
    switch(noisyMic) {
      case 1: position = "GÃ³c trÃ¡i trÆ°á»›c"; break;
      case 2: position = "GÃ³c pháº£i trÆ°á»›c"; break;
      case 3: position = "GÃ³c trÃ¡i sau"; break;
      case 4: position = "GÃ³c pháº£i sau"; break;
    }
    Serial.printf("ğŸš¨ Nguá»“n á»“n phÃ¡t hiá»‡n: Mic #%d (%s) - %.1f dB\n", 
                  noisyMic, position.c_str(), maxDB);
  }
}

void setup() {
  Serial.begin(115200);
  delay(1000);
  
  Serial.println("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
  Serial.println("â•‘   ğŸ“ ESP32-S Master + TinyML (4 Slaves)       â•‘");
  Serial.println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");

  WiFi.mode(WIFI_STA);
  Serial.print("\nğŸ“ Master MAC Address: ");
  Serial.println(WiFi.macAddress());
  Serial.println("âš ï¸  DÃ¹ng MAC nÃ y cho masterAddress trong slaves!\n");

  if (esp_now_init() != ESP_OK) {
    Serial.println("âŒ Lá»—i khá»Ÿi táº¡o ESP-NOW");
    return;
  }

  esp_now_register_recv_cb(OnDataRecv);
  
  Serial.println("âœ… Sáºµn sÃ ng nháº­n dá»¯ liá»‡u tá»« 4 slaves...");
  Serial.println("ğŸ¤ Vá»‹ trÃ­ Ä‘á» xuáº¥t:");
  Serial.println("   Mic #1: GÃ³c trÃ¡i trÆ°á»›c");
  Serial.println("   Mic #2: GÃ³c pháº£i trÆ°á»›c");
  Serial.println("   Mic #3: GÃ³c trÃ¡i sau");
  Serial.println("   Mic #4: GÃ³c pháº£i sau\n");
}

void loop() {
  checkMicStatus();
  printDashboard();
  locateNoiseSource();
  
  delay(100);
}
