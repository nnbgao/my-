/*
  === ESP32-C3 + INMP441 - Voice Activity Detection (VAD) ===
  Features tối ưu cho nhận diện giọng nói
*/

#include <Arduino.h>
#include <driver/i2s.h>
#include <arduinoFFT.h>

#define I2S_WS  4
#define I2S_SD  5
#define I2S_SCK 6

#define SAMPLE_RATE 16000
#define SAMPLES 512

ArduinoFFT<double> FFT = ArduinoFFT<double>();
double vReal[SAMPLES];
double vImag[SAMPLES];

// Features cho Voice Detection
struct VoiceFeatures {
  float dB;                // Âm lượng tổng
  float energy;            // Năng lượng tín hiệu
  float zcr;               // Zero Crossing Rate (đặc trưng giọng nói)
  float spectralCentroid;  // Trọng tâm phổ tần
  float voiceBand;         // 300-3400 Hz (dải tần giọng nói)
  float lowFreq;           // 85-255 Hz (fundamental frequency)
  float highFreq;          // 3400-8000 Hz
  float spectralFlux;      // Biến thiên phổ
};

VoiceFeatures features;
double prevSpectrum[SAMPLES/2];

void setupI2S() {
  i2s_config_t i2s_config = {
    .mode = (i2s_mode_t)(I2S_MODE_MASTER | I2S_MODE_RX),
    .sample_rate = SAMPLE_RATE,
    .bits_per_sample = I2S_BITS_PER_SAMPLE_32BIT,
    .channel_format = I2S_CHANNEL_FMT_ONLY_LEFT,
    .communication_format = I2S_COMM_FORMAT_I2S,
    .intr_alloc_flags = 0,
    .dma_buf_count = 8,
    .dma_buf_len = 64,
    .use_apll = false
  };
  i2s_pin_config_t pin_config = {
    .bck_io_num = I2S_SCK,
    .ws_io_num = I2S_WS,
    .data_out_num = I2S_PIN_NO_CHANGE,
    .data_in_num = I2S_SD
  };
  i2s_driver_install(I2S_NUM_0, &i2s_config, 0, NULL);
  i2s_set_pin(I2S_NUM_0, &pin_config);
  i2s_zero_dma_buffer(I2S_NUM_0);
}

// Tính Zero Crossing Rate (cao = noise, trung bình = giọng nói)
float calculateZCR(int32_t *data, int samples) {
  int zeroCrossings = 0;
  for (int i = 1; i < samples; i++) {
    if ((data[i] >= 0 && data[i-1] < 0) || (data[i] < 0 && data[i-1] >= 0)) {
      zeroCrossings++;
    }
  }
  return (float)zeroCrossings / samples;
}

// Tính năng lượng
float calculateEnergy(int32_t *data, int samples) {
  double sum = 0;
  for (int i = 0; i < samples; i++) {
    double x = (double)data[i] / 2147483648.0;
    sum += x * x;
  }
  return sum / samples;
}

// Tính RMS cho dB
double calculateRMS(int32_t *data, int samples) {
  double mean = 0;
  for (int i = 0; i < samples; i++) mean += data[i];
  mean /= samples;
  double sum = 0;
  for (int i = 0; i < samples; i++) {
    double x = (data[i] - mean) / 2147483648.0;
    sum += x * x;
  }
  return sqrt(sum / samples);
}

// Phân tích FFT cho Voice Detection
void analyzeVoiceFFT(int32_t *buffer) {
  // Chuẩn bị FFT
  for (int i = 0; i < SAMPLES; i++) {
    vReal[i] = (double)buffer[i] / 2147483648.0;
    vImag[i] = 0;
  }

  FFT.windowing(vReal, SAMPLES, FFT_WIN_TYP_HAMMING, FFT_FORWARD);
  FFT.compute(vReal, vImag, SAMPLES, FFT_FORWARD);
  FFT.complexToMagnitude(vReal, vImag, SAMPLES);

  double freqResolution = (double)SAMPLE_RATE / SAMPLES;
  
  // Reset
  double voiceSum = 0, lowSum = 0, highSum = 0;
  int voiceCount = 0, lowCount = 0, highCount = 0;
  double totalMagnitude = 0;
  double weightedFreq = 0;
  double spectralFlux = 0;

  for (int i = 1; i < SAMPLES / 2; i++) {
    double freq = i * freqResolution;
    double magnitude = vReal[i];
    
    totalMagnitude += magnitude;
    weightedFreq += freq * magnitude;
    
    // Spectral Flux (so sánh với frame trước)
    spectralFlux += fabs(magnitude - prevSpectrum[i]);
    prevSpectrum[i] = magnitude;

    // Dải tần giọng nói (300-3400 Hz - telephone bandwidth)
    if (freq >= 300 && freq < 3400) {
      voiceSum += magnitude;
      voiceCount++;
    }
    
    // Fundamental frequency (85-255 Hz - pitch của giọng nói)
    if (freq >= 85 && freq < 255) {
      lowSum += magnitude;
      lowCount++;
    }
    
    // High frequency
    if (freq >= 3400 && freq < 8000) {
      highSum += magnitude;
      highCount++;
    }
  }

  // Tính Spectral Centroid (trọng tâm phổ)
  features.spectralCentroid = totalMagnitude > 0 ? (weightedFreq / totalMagnitude) : 0;
  
  features.voiceBand = voiceCount > 0 ? (voiceSum / voiceCount) : 0;
  features.lowFreq = lowCount > 0 ? (lowSum / lowCount) : 0;
  features.highFreq = highCount > 0 ? (highSum / highCount) : 0;
  features.spectralFlux = spectralFlux / (SAMPLES / 2);
}

void setup() {
  Serial.begin(115200);
  delay(1000);
  
  // CSV Header cho Edge Impulse
  Serial.println("timestamp,dB,energy,zcr,spectralCentroid,voiceBand,lowFreq,highFreq,spectralFlux");
  
  setupI2S();
  
  // Khởi tạo prevSpectrum
  for (int i = 0; i < SAMPLES/2; i++) prevSpectrum[i] = 0;
}

void loop() {
  size_t bytes_read;
  int32_t buffer[SAMPLES];
  
  i2s_read(I2S_NUM_0, (void*)buffer, sizeof(buffer), &bytes_read, portMAX_DELAY);

  // Tính các features
  double rms = calculateRMS(buffer, SAMPLES);
  if (rms < 0.0000001) rms = 0.0000001;
  features.dB = 20 * log10(rms) + 94;
  
  features.energy = calculateEnergy(buffer, SAMPLES);
  features.zcr = calculateZCR(buffer, SAMPLES);
  
  analyzeVoiceFFT(buffer);

  // Output CSV format
  Serial.printf("%lu,%.2f,%.6f,%.4f,%.2f,%.6f,%.6f,%.6f,%.6f\n", 
    millis(),
    features.dB,
    features.energy,
    features.zcr,
    features.spectralCentroid,
    features.voiceBand,
    features.lowFreq,
    features.highFreq,
    features.spectralFlux
  );
  
  delay(100);  // 10 samples/giây
}
