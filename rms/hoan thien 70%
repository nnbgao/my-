#include <Arduino.h>
#include <driver/i2s.h>
#include <WiFi.h>
#include <HTTPClient.h>
#include <SPIFFS.h>
#include <math.h>

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Cáº¤U HÃŒNH PHáº¦N Cá»¨NG
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const char* ssid = "YOUR_WIFI_SSID";
const char* password = "YOUR_WIFI_PASSWORD";
const char* scriptURL = "YOUR_APPS_SCRIPT_URL";

// MIC 1 (Primary - Trong lá»›p, gáº§n giÃ¡o viÃªn)
#define I2S_WS_1    15
#define I2S_SD_1    32
#define I2S_SCK_1   14

// MIC 2 (Reference - Gáº§n cá»­a, hÆ°á»›ng ra ngoÃ i)
#define I2S_WS_2    25
#define I2S_SD_2    33
#define I2S_SCK_2   26

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Cáº¤U HÃŒNH GHI Ã‚M & ANC
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

#define SAMPLE_RATE   16000
#define RECORD_TIME   5
#define I2S_PORT_1    I2S_NUM_0
#define I2S_PORT_2    I2S_NUM_1
#define BUFFER_SIZE   1024

// ANC Parameters
#define ANC_ENABLE true
#define NOISE_GATE_THRESHOLD 350
#define ADAPTIVE_FILTER_SIZE 64
#define SMOOTHING_FACTOR 0.88f
#define LEARNING_RATE 0.008f

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// WAV HEADER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

typedef struct {
  char riff[4];
  uint32_t fileSize;
  char wave[4];
  char fmt[4];
  uint32_t fmtSize;
  uint16_t audioFormat;
  uint16_t channels;
  uint32_t sampleRate;
  uint32_t byteRate;
  uint16_t blockAlign;
  uint16_t bitsPerSample;
  char data[4];
  uint32_t dataSize;
} WAVHeader;

void createWAVHeader(WAVHeader* header, uint32_t dataSize) {
  memcpy(header->riff, "RIFF", 4);
  header->fileSize = dataSize + 36;
  memcpy(header->wave, "WAVE", 4);
  memcpy(header->fmt, "fmt ", 4);
  header->fmtSize = 16;
  header->audioFormat = 1;
  header->channels = 1;
  header->sampleRate = SAMPLE_RATE;
  header->bitsPerSample = 16;
  header->byteRate = SAMPLE_RATE * 2;
  header->blockAlign = 2;
  memcpy(header->data, "data", 4);
  header->dataSize = dataSize;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HELPER: ÄÃšNG CÃCH Äá»ŒC INMP441 24-BIT DATA
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

int16_t extractSample(int32_t raw32bit) {
  // INMP441: 24-bit data á»Ÿ bits [31:8]
  return (int16_t)(raw32bit >> 14);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ADAPTIVE FILTER (LMS Algorithm)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class AdaptiveFilter {
private:
  float* weights;
  float* buffer;
  int filterSize;
  float learningRate;
  int bufferIndex;
  
public:
  AdaptiveFilter(int size, float lr) 
    : filterSize(size), learningRate(lr), bufferIndex(0) {
    weights = (float*)calloc(size, sizeof(float));
    buffer = (float*)calloc(size, sizeof(float));
  }
  
  ~AdaptiveFilter() {
    free(weights);
    free(buffer);
  }
  
  int16_t process(int16_t primary, int16_t reference) {
    buffer[bufferIndex] = (float)reference;
    
    float filterOutput = 0.0f;
    for (int i = 0; i < filterSize; i++) {
      int idx = (bufferIndex - i + filterSize) % filterSize;
      filterOutput += weights[i] * buffer[idx];
    }
    
    float error = (float)primary - filterOutput;
    
    for (int i = 0; i < filterSize; i++) {
      int idx = (bufferIndex - i + filterSize) % filterSize;
      weights[i] += learningRate * error * buffer[idx];
      weights[i] = constrain(weights[i], -10.0f, 10.0f);
    }
    
    bufferIndex = (bufferIndex + 1) % filterSize;
    
    return (int16_t)constrain(error, -32768.0f, 32767.0f);
  }
  
  void reset() {
    memset(weights, 0, filterSize * sizeof(float));
    memset(buffer, 0, filterSize * sizeof(float));
    bufferIndex = 0;
  }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// NOISE GATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class NoiseGate {
private:
  int16_t threshold;
  float smoothedLevel;
  
public:
  NoiseGate(int16_t thresh) 
    : threshold(thresh), smoothedLevel(0.0f) {}
  
  int16_t process(int16_t sample) {
    float level = abs(sample);
    
    if (level > smoothedLevel) {
      smoothedLevel = 0.1f * level + 0.9f * smoothedLevel;
    } else {
      smoothedLevel = 0.3f * level + 0.7f * smoothedLevel;
    }
    
    if (smoothedLevel < threshold) {
      float attenuation = smoothedLevel / threshold;
      return (int16_t)(sample * attenuation);
    }
    
    return sample;
  }
  
  void setThreshold(int16_t thresh) { 
    threshold = thresh; 
  }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HIGH-PASS FILTER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class HighPassFilter {
private:
  float x1, x2, y1, y2;
  float b0, b1, b2, a1, a2;
  
public:
  HighPassFilter(float cutoffHz, float sampleRate) {
    float fc = cutoffHz / sampleRate;
    float K = tan(PI * fc);
    float Q = 0.7071f;
    float norm = 1.0f / (1.0f + K / Q + K * K);
    
    b0 = norm;
    b1 = -2.0f * norm;
    b2 = norm;
    a1 = 2.0f * (K * K - 1.0f) * norm;
    a2 = (1.0f - K / Q + K * K) * norm;
    
    reset();
  }
  
  void reset() {
    x1 = x2 = y1 = y2 = 0.0f;
  }
  
  int16_t process(int16_t input) {
    float x0 = (float)input;
    float y0 = b0 * x0 + b1 * x1 + b2 * x2 - a1 * y1 - a2 * y2;
    
    x2 = x1; 
    x1 = x0;
    y2 = y1; 
    y1 = y0;
    
    return (int16_t)constrain(y0, -32768.0f, 32767.0f);
  }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// I2S SETUP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void setupI2S(i2s_port_t port, int ws, int sd, int sck) {
  i2s_config_t i2s_config = {
    .mode = (i2s_mode_t)(I2S_MODE_MASTER | I2S_MODE_RX),
    .sample_rate = SAMPLE_RATE,
    .bits_per_sample = I2S_BITS_PER_SAMPLE_32BIT,
    .channel_format = I2S_CHANNEL_FMT_ONLY_LEFT,
    .communication_format = I2S_COMM_FORMAT_I2S,
    .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1,
    .dma_buf_count = 8,
    .dma_buf_len = BUFFER_SIZE,
    .use_apll = false,
    .tx_desc_auto_clear = false,
    .fixed_mclk = 0
  };

  i2s_pin_config_t pin_config = {
    .bck_io_num = sck,
    .ws_io_num = ws,
    .data_out_num = I2S_PIN_NO_CHANGE,
    .data_in_num = sd
  };

  esp_err_t err = i2s_driver_install(port, &i2s_config, 0, NULL);
  if (err != ESP_OK) {
    Serial.printf("âŒ I2S install failed: %d\n", err);
    return;
  }
  
  i2s_set_pin(port, &pin_config);
  i2s_zero_dma_buffer(port);
  
  Serial.printf("âœ… I2S Port %d OK\n", port);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TEST MIC LEVELS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void testMicLevels(int seconds) {
  Serial.println("\nğŸ¤ TESTING MIC LEVELS...");
  Serial.println("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
  
  int32_t buffer1[BUFFER_SIZE];
  int32_t buffer2[BUFFER_SIZE];
  size_t bytesRead;
  
  unsigned long startTime = millis();
  unsigned long duration = seconds * 1000;
  
  int64_t rms1Sum = 0;
  int64_t rms2Sum = 0;
  int sampleCount = 0;
  
  while (millis() - startTime < duration) {
    i2s_read(I2S_PORT_1, buffer1, BUFFER_SIZE * 4, &bytesRead, portMAX_DELAY);
    i2s_read(I2S_PORT_2, buffer2, BUFFER_SIZE * 4, &bytesRead, portMAX_DELAY);
    
    size_t samples = bytesRead / 4;
    
    for (int i = 0; i < samples; i++) {
      int16_t s1 = extractSample(buffer1[i]);
      int16_t s2 = extractSample(buffer2[i]);
      
      rms1Sum += (int32_t)s1 * s1;
      rms2Sum += (int32_t)s2 * s2;
      sampleCount++;
    }
    
    if ((millis() - startTime) % 500 < 50) {
      Serial.print(".");
    }
  }
  
  float rms1 = sqrt((float)rms1Sum / sampleCount);
  float rms2 = sqrt((float)rms2Sum / sampleCount);
  
  Serial.println();
  Serial.println("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
  Serial.printf("ğŸ“Š MIC 1 RMS: %.1f\n", rms1);
  Serial.printf("ğŸ“Š MIC 2 RMS: %.1f\n", rms2);
  Serial.printf("ğŸ“Š Samples: %d\n", sampleCount);
  
  if (rms1 < 100 || rms2 < 100) {
    Serial.println("âš ï¸  RMS quÃ¡ tháº¥p! Kiá»ƒm tra káº¿t ná»‘i mic.");
  } else {
    Serial.println("âœ… Mic levels OK!");
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RECORD AUDIO WITH ANC
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void recordAudioWithANC(const char* filename) {
  File file = SPIFFS.open(filename, FILE_WRITE);
  if (!file) {
    Serial.println("âŒ KhÃ´ng thá»ƒ táº¡o file!");
    return;
  }

  WAVHeader header;
  file.write((uint8_t*)&header, sizeof(WAVHeader));

  // Initialize processing chain
  AdaptiveFilter adaptiveFilter(ADAPTIVE_FILTER_SIZE, LEARNING_RATE);
  NoiseGate noiseGate(NOISE_GATE_THRESHOLD);
  HighPassFilter hpf(80.0f, (float)SAMPLE_RATE);
  
  int32_t* buffer1 = (int32_t*)malloc(BUFFER_SIZE * sizeof(int32_t));
  int32_t* buffer2 = (int32_t*)malloc(BUFFER_SIZE * sizeof(int32_t));
  int16_t* outputBuffer = (int16_t*)malloc(BUFFER_SIZE * sizeof(int16_t));
  
  if (!buffer1 || !buffer2 || !outputBuffer) {
    Serial.println("âŒ KhÃ´ng Ä‘á»§ RAM!");
    file.close();
    return;
  }

  uint32_t totalDataSize = 0;
  uint32_t totalSamples = SAMPLE_RATE * RECORD_TIME;
  uint32_t samplesRecorded = 0;
  int noiseCancelledSamples = 0;
  size_t bytesRead1, bytesRead2;

  Serial.println("\nğŸ™ï¸  GHI Ã‚M Vá»šI ANC...");
  Serial.println("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
  
  unsigned long startTime = millis();

  while (samplesRecorded < totalSamples) {
    // Äá»c tá»« cáº£ 2 mic
    i2s_read(I2S_PORT_1, buffer1, BUFFER_SIZE * 4, &bytesRead1, portMAX_DELAY);
    i2s_read(I2S_PORT_2, buffer2, BUFFER_SIZE * 4, &bytesRead2, portMAX_DELAY);
    
    size_t samples = min(bytesRead1, bytesRead2) / 4;
    
    // Process samples
    for (int i = 0; i < samples && samplesRecorded < totalSamples; i++) {
      int16_t primary = extractSample(buffer1[i]);
      int16_t reference = extractSample(buffer2[i]);
      
      int16_t processed = primary;
      
      if (ANC_ENABLE) {
        processed = hpf.process(processed);
        processed = adaptiveFilter.process(processed, reference);
        
        int16_t gated = noiseGate.process(processed);
        if (gated == 0) noiseCancelledSamples++;
        processed = gated;
      }
      
      outputBuffer[i] = processed;
      samplesRecorded++;
    }
    
    // Write to file
    size_t bytesToWrite = samples * 2;
    file.write((uint8_t*)outputBuffer, bytesToWrite);
    totalDataSize += bytesToWrite;
    
    // Progress
    int progress = (samplesRecorded * 100) / totalSamples;
    if (progress % 20 == 0 && samplesRecorded % (SAMPLE_RATE / 2) == 0) {
      Serial.printf("[%d%%] ", progress);
    }
  }

  unsigned long elapsed = millis() - startTime;
  float noiseReduction = (noiseCancelledSamples * 100.0f) / samplesRecorded;
  
  Serial.println();
  Serial.println("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
  Serial.printf("âœ… HoÃ n táº¥t! Thá»i gian: %.1f s\n", elapsed / 1000.0f);
  Serial.printf("ğŸ“Š Size: %d KB\n", totalDataSize / 1024);
  Serial.printf("ğŸ”‡ Nhiá»…u lá»c: %.1f%%\n", noiseReduction);
  Serial.printf("ğŸ’¾ RAM cÃ²n: %d KB\n", ESP.getFreeHeap() / 1024);

  // Update header
  file.seek(0);
  createWAVHeader(&header, totalDataSize);
  file.write((uint8_t*)&header, sizeof(WAVHeader));
  file.close();
  
  free(buffer1);
  free(buffer2);
  free(outputBuffer);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SETUP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void setup() {
  Serial.begin(115200);
  delay(1000);
  
  Serial.println("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
  Serial.println("â•‘  ESP32 DUAL MIC + ANC v3.0 FIXED     â•‘");
  Serial.println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
  
  // SPIFFS
  if (!SPIFFS.begin(true)) {
    Serial.println("âŒ SPIFFS failed!");
    while(1) delay(1000);
  }
  Serial.println("âœ… SPIFFS OK");
  
  // WiFi
  Serial.printf("ğŸ“¶ Connecting to %s...\n", ssid);
  WiFi.begin(ssid, password);
  
  int attempts = 0;
  while (WiFi.status() != WL_CONNECTED && attempts < 30) {
    delay(500);
    Serial.print(".");
    attempts++;
  }
  Serial.println();
  
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("âœ… WiFi: " + WiFi.localIP().toString());
  } else {
    Serial.println("âš ï¸  WiFi failed");
  }
  
  // I2S Setup
  Serial.println("\nğŸ›ï¸  Initializing I2S...");
  setupI2S(I2S_PORT_1, I2S_WS_1, I2S_SD_1, I2S_SCK_1);
  setupI2S(I2S_PORT_2, I2S_WS_2, I2S_SD_2, I2S_SCK_2);
  
  delay(1000);
  
  // Test mics
  testMicLevels(3);
  
  Serial.println("\nğŸš€ READY!\n");
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LOOP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void loop() {
  const char* audioFile = "/recording.wav";
  
  Serial.println("ğŸ¬ RECORDING...\n");
  
  recordAudioWithANC(audioFile);
  
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\nâ˜ï¸  Upload would happen here");
    // uploadFileInChunks(audioFile);
  }
  
  SPIFFS.remove(audioFile);
  
  Serial.println("\nâ³ Wait 10s...\n");
  delay(10000);
}

/*
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                         COMPILATION FIXES                                  â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

âœ… ThÃªm #include <math.h> cho sqrt()
âœ… Sá»­a M_PI â†’ PI (Arduino constant)
âœ… ThÃªm float cast cho constrain()
âœ… Sá»­a constructor initialization order
âœ… Fix default parameter trong function definition
âœ… Remove struct forward declaration issues
âœ… Fix memory allocation checks

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ“‹ CHECKLIST TRÆ¯á»šC KHI COMPILE:

1. Board: ESP32 Dev Module
2. Partition Scheme: Default 4MB with SPIFFS
3. PSRAM: Disabled (hoáº·c Enabled náº¿u cÃ³)
4. Upload Speed: 921600
5. Sá»­a YOUR_WIFI_SSID vÃ  YOUR_WIFI_PASSWORD

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ¯ Náº¾U VáºªN Lá»–I:

Gá»­i FULL error message tá»« Arduino IDE Ä‘á»ƒ tÃ´i fix chÃ­nh xÃ¡c!

*/
