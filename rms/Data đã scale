/*
  === ESP32-C3 + INMP441 - Voice Activity Detection (VAD) ===
  Features tối ưu với nhiều phương pháp scaling
*/

#include <Arduino.h>
#include <driver/i2s.h>
#include <arduinoFFT.h>

#define I2S_WS  4
#define I2S_SD  5
#define I2S_SCK 6

#define SAMPLE_RATE 16000
#define SAMPLES 512

// Chọn phương pháp scaling (uncomment 1 trong 3)
#define USE_SCALE_MULTIPLY    // Nhân với hằng số lớn
// #define USE_SQRT_SCALE     // Căn bậc 4 (ít nén hơn log)
// #define USE_ADAPTIVE_SCALE // Tự động scale theo range

ArduinoFFT<double> FFT = ArduinoFFT<double>();
double vReal[SAMPLES];
double vImag[SAMPLES];

struct VoiceFeatures {
  float dB;
  float energy;
  float zcr;
  float spectralCentroid;
  float voiceBand;
  float lowFreq;
  float highFreq;
  float spectralFlux;
};

VoiceFeatures features;
double prevSpectrum[SAMPLES/2];

// Phương pháp 1: Nhân với hằng số lớn
float scaleMultiply(float value) {
  return value * 1000000.0;  // Scale x 1 triệu
}

// Phương pháp 2: Căn bậc 4 (ít nén hơn log)
float scaleSqrt(float value) {
  if (value < 1e-10) return 0;
  return sqrt(sqrt(value)) * 1000;  // Căn bậc 4 rồi nhân 1000
}

// Phương pháp 3: Min-Max Scaling (0-100)
float scaleAdaptive(float value, float minVal, float maxVal) {
  if (maxVal - minVal < 1e-10) return 0;
  return ((value - minVal) / (maxVal - minVal)) * 100.0;
}

// Tracking min/max cho adaptive scaling
struct MinMax {
  float voiceBandMin = 1e10, voiceBandMax = -1e10;
  float lowFreqMin = 1e10, lowFreqMax = -1e10;
  float highFreqMin = 1e10, highFreqMax = -1e10;
  float energyMin = 1e10, energyMax = -1e10;
  float fluxMin = 1e10, fluxMax = -1e10;
} minmax;

void updateMinMax(float &minVal, float &maxVal, float value) {
  if (value < minVal) minVal = value;
  if (value > maxVal) maxVal = value;
}

void setupI2S() {
  i2s_config_t i2s_config = {
    .mode = (i2s_mode_t)(I2S_MODE_MASTER | I2S_MODE_RX),
    .sample_rate = SAMPLE_RATE,
    .bits_per_sample = I2S_BITS_PER_SAMPLE_32BIT,
    .channel_format = I2S_CHANNEL_FMT_ONLY_LEFT,
    .communication_format = I2S_COMM_FORMAT_I2S,
    .intr_alloc_flags = 0,
    .dma_buf_count = 8,
    .dma_buf_len = 64,
    .use_apll = false
  };
  i2s_pin_config_t pin_config = {
    .bck_io_num = I2S_SCK,
    .ws_io_num = I2S_WS,
    .data_out_num = I2S_PIN_NO_CHANGE,
    .data_in_num = I2S_SD
  };
  i2s_driver_install(I2S_NUM_0, &i2s_config, 0, NULL);
  i2s_set_pin(I2S_NUM_0, &pin_config);
  i2s_zero_dma_buffer(I2S_NUM_0);
}

float calculateZCR(int32_t *data, int samples) {
  int zeroCrossings = 0;
  for (int i = 1; i < samples; i++) {
    if ((data[i] >= 0 && data[i-1] < 0) || (data[i] < 0 && data[i-1] >= 0)) {
      zeroCrossings++;
    }
  }
  return (float)zeroCrossings / samples;
}

float calculateEnergy(int32_t *data, int samples) {
  double sum = 0;
  for (int i = 0; i < samples; i++) {
    double x = (double)data[i] / 2147483648.0;
    sum += x * x;
  }
  return sum / samples;
}

double calculateRMS(int32_t *data, int samples) {
  double mean = 0;
  for (int i = 0; i < samples; i++) mean += data[i];
  mean /= samples;
  double sum = 0;
  for (int i = 0; i < samples; i++) {
    double x = (data[i] - mean) / 2147483648.0;
    sum += x * x;
  }
  return sqrt(sum / samples);
}

void analyzeVoiceFFT(int32_t *buffer) {
  for (int i = 0; i < SAMPLES; i++) {
    vReal[i] = (double)buffer[i] / 2147483648.0;
    vImag[i] = 0;
  }

  FFT.windowing(vReal, SAMPLES, FFT_WIN_TYP_HAMMING, FFT_FORWARD);
  FFT.compute(vReal, vImag, SAMPLES, FFT_FORWARD);
  FFT.complexToMagnitude(vReal, vImag, SAMPLES);

  double freqResolution = (double)SAMPLE_RATE / SAMPLES;
  
  double voiceSum = 0, lowSum = 0, highSum = 0;
  int voiceCount = 0, lowCount = 0, highCount = 0;
  double totalMagnitude = 0;
  double weightedFreq = 0;
  double spectralFlux = 0;

  for (int i = 1; i < SAMPLES / 2; i++) {
    double freq = i * freqResolution;
    double magnitude = vReal[i];
    
    totalMagnitude += magnitude;
    weightedFreq += freq * magnitude;
    
    spectralFlux += fabs(magnitude - prevSpectrum[i]);
    prevSpectrum[i] = magnitude;

    if (freq >= 300 && freq < 3400) {
      voiceSum += magnitude;
      voiceCount++;
    }
    
    if (freq >= 85 && freq < 255) {
      lowSum += magnitude;
      lowCount++;
    }
    
    if (freq >= 3400 && freq < 8000) {
      highSum += magnitude;
      highCount++;
    }
  }

  features.spectralCentroid = totalMagnitude > 0 ? (weightedFreq / totalMagnitude) : 0;
  features.voiceBand = voiceCount > 0 ? (voiceSum / voiceCount) : 0;
  features.lowFreq = lowCount > 0 ? (lowSum / lowCount) : 0;
  features.highFreq = highCount > 0 ? (highSum / highCount) : 0;
  features.spectralFlux = spectralFlux / (SAMPLES / 2);
}

void setup() {
  Serial.begin(115200);
  delay(1000);
  
  Serial.println("timestamp,dB,energy,zcr,spectralCentroid,voiceBand,lowFreq,highFreq,spectralFlux");
  
  setupI2S();
  
  for (int i = 0; i < SAMPLES/2; i++) prevSpectrum[i] = 0;
}

void loop() {
  size_t bytes_read;
  int32_t buffer[SAMPLES];
  
  i2s_read(I2S_NUM_0, (void*)buffer, sizeof(buffer), &bytes_read, portMAX_DELAY);

  double rms = calculateRMS(buffer, SAMPLES);
  if (rms < 0.0000001) rms = 0.0000001;
  features.dB = 20 * log10(rms) + 94;
  
  features.energy = calculateEnergy(buffer, SAMPLES);
  features.zcr = calculateZCR(buffer, SAMPLES);
  
  analyzeVoiceFFT(buffer);

  // Áp dụng scaling
  float energy_scaled, voiceBand_scaled, lowFreq_scaled, highFreq_scaled, spectralFlux_scaled;

#ifdef USE_SCALE_MULTIPLY
  energy_scaled = scaleMultiply(features.energy);
  voiceBand_scaled = scaleMultiply(features.voiceBand);
  lowFreq_scaled = scaleMultiply(features.lowFreq);
  highFreq_scaled = scaleMultiply(features.highFreq);
  spectralFlux_scaled = scaleMultiply(features.spectralFlux);
  
#elif defined(USE_SQRT_SCALE)
  energy_scaled = scaleSqrt(features.energy);
  voiceBand_scaled = scaleSqrt(features.voiceBand);
  lowFreq_scaled = scaleSqrt(features.lowFreq);
  highFreq_scaled = scaleSqrt(features.highFreq);
  spectralFlux_scaled = scaleSqrt(features.spectralFlux);
  
#elif defined(USE_ADAPTIVE_SCALE)
  // Update min/max
  updateMinMax(minmax.energyMin, minmax.energyMax, features.energy);
  updateMinMax(minmax.voiceBandMin, minmax.voiceBandMax, features.voiceBand);
  updateMinMax(minmax.lowFreqMin, minmax.lowFreqMax, features.lowFreq);
  updateMinMax(minmax.highFreqMin, minmax.highFreqMax, features.highFreq);
  updateMinMax(minmax.fluxMin, minmax.fluxMax, features.spectralFlux);
  
  energy_scaled = scaleAdaptive(features.energy, minmax.energyMin, minmax.energyMax);
  voiceBand_scaled = scaleAdaptive(features.voiceBand, minmax.voiceBandMin, minmax.voiceBandMax);
  lowFreq_scaled = scaleAdaptive(features.lowFreq, minmax.lowFreqMin, minmax.lowFreqMax);
  highFreq_scaled = scaleAdaptive(features.highFreq, minmax.highFreqMin, minmax.highFreqMax);
  spectralFlux_scaled = scaleAdaptive(features.spectralFlux, minmax.fluxMin, minmax.fluxMax);
#endif

  Serial.printf("%lu,%.2f,%.2f,%.4f,%.2f,%.2f,%.2f,%.2f,%.2f\n", 
    millis(),
    features.dB,
    energy_scaled,
    features.zcr,
    features.spectralCentroid,
    voiceBand_scaled,
    lowFreq_scaled,
    highFreq_scaled,
    spectralFlux_scaled
  );
  
  delay(100);
}
